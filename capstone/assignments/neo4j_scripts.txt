MATCH (n)OPTIONAL MATCH (n)-[r]-()DELETE n,rMATCH (n)RETURN count(n);MATCH (n)-[r]-()RETURN count(r)CREATE CONSTRAINT ON (u:User) ASSERT u.id IS UNIQUE; CREATE CONSTRAINT ON (t:Team) ASSERT t.id IS UNIQUE; CREATE CONSTRAINT ON (c:TeamChatSession) ASSERT c.id IS UNIQUE; CREATE CONSTRAINT ON (i:ChatItem) ASSERT i.id IS UNIQUE; LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_create_team_chat.csv" AS row MERGE (u:User {id: toInt(row[0])}) MERGE (t:Team {id: toInt(row[1])}) MERGE (c:TeamChatSession {id: toInt(row[2])}) MERGE (u)-[:CreatesSession{timeStamp: row[3]}]->(c) MERGE (c)-[:OwnedBy{timeStamp: row[3]}]->(t)LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_join_team_chat.csv" AS row MERGE (u:User {id: toInt(row[0])}) MERGE (c:TeamChatSession {id: toInt(row[1])}) MERGE (u)-[:Join{timeStamp: row[2]}]->(c)LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_leave_team_chat.csv" AS row MERGE (u:User {id: toInt(row[0])}) MERGE (c:TeamChatSession {id: toInt(row[1])}) MERGE (u)-[:Leave{timeStamp: row[2]}]->(c)LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_item_team_chat.csv" AS row MERGE (u:User {id: toInt(row[0])}) MERGE (c:TeamChatSession {id: toInt(row[1])}) MERGE (i:ChatItem {id: toInt(row[2])}) MERGE (u)-[:CreateChat{timeStamp: row[3]}]->(i) MERGE (i)-[:PartOf{timeStamp: row[3]}]->(c)LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_mention_team_chat.csv" AS row MERGE (i:ChatItem {id: toInt(row[0])}) MERGE (u:User {id: toInt(row[1])}) MERGE (i)-[:Mentioned {timeStamp: row[2]}]->(u)LOAD CSV FROM "file:///Users/iBowen/Desktop/chat-data/chat_respond_team_chat.csv" AS row MERGE (i:ChatItem {id: toInt(row[0])}) MERGE (j:ChatItem {id: toInt(row[1])}) MERGE (i)-[:ResponseTo {timeStamp: row[2]}]->(j)Question 1: Find the longest conversation chain in the chat data using the "ResponseTo" edge label. This question has two parts, 1) How many chats are involved in it? , and match p=(i:ChatItem)-[:ResponseTo*]-(j:ChatItem) return length(p) order by length(p) desc limit 12) How many users participated in this chain?match p=(i:ChatItem)-[:ResponseTo*]-(j:ChatItem) with p order by length(p) desc limit 1match (u:User)-[:CreateChat]-(i)where i in nodes(p)return count(distinct u)Question 2:Do the top 10 the chattiest users belong to the top 10 chattiest teams?1): find the chattiest users, MATCH all Users with a CreateChat edge, return the Users (their ID) and the count of the Users and sort them in descending order and limit the results to 10.match (u:User)-[:CreateChat]-(i:ChatItem) return u.id, count(u.id) order by count(u.id) desc limit 102): find the top 10 chattiest teams, MATCH all ChatItems with a PartOf edge connecting them with a TeamChatSession node AND the TeamChatSession nodes must have an OwnedBy edge connecting them with any other node. match (i:ChatItem)-[:PartOf]->(c:TeamChatSession)-[:OwnedBy]->(t:Team) return t.id, count(t.id) order by count(t.id) desc limit 10match p=(u:User)-[:Join]-(c:TeamChatSession)-[:OwnedBy]-(t:Team) where t.id in [82,185,112,18,194,129,52,136,146,81] and u.id in [394,2067,209,1087,554,516,1627,999,668,461] return pQuestion 3:How Active are Groups of Users?1. connect two users if One mentioned another user in a chatMatch (u1:User)-[:CreateChat]->(i:ChatItem)-[:Mentioned]->(u2:User) merge (u1)-[:InteractsWith]->(u2)2. connect two users if One created a chatItem in response to another user’s chatItemMatch (u1:User)-[:CreateChat]->(i1:ChatItem)-[:ResponseTo]-(i2:ChatItem)<-[:CreateChat]-(u2:User) merge (u1)-[:InteractsWith]->(u2)3. delete self-loop InteractsWith relationshipmatch (u1)-[r:InteractsWith]->(u1) delete r4. get neighbors and set degree based on the number of neighbors on the “InteractsWith” edge.match (u1:User)-[r:InteractsWith]-(u2:User) with u1, count(distinct u2) as degreeset u1.deg = degreereturn u1.id, u1.deg5. get the number of links amongst neighbors.# find the neighbors users of one user node, and collect all distinct neighbor ids. # find all links amongst neighbors# count 1 if there are one or more relationships between two neighbors. # sum all links amongst neighbors# calculate the clustering efficient and set properties on each user node# rank top 10 users by clustering coefficientmatch (u1:User)-[:InteractsWith]-(u2:User)with u1, collect(distinct u2.id) as neighborsmatch (n:User)-[r:InteractsWith]->(m:User)  where (n.id in neighbors) and (m.id in neighbors)with u1, case when (n)-->(m) then 1else 0 end as valuewith u1, u1.deg as deg, sum(value) as linksset u1.cc = toFloat(links) / (deg * (deg - 1))return u1.id, u1.deg, u1.ccmatch (u:User) where u.id in [394, 2067, 209, 1087, 554, 516, 1627, 999, 668, 461]with u.id as id, u.deg as degree, u.cc as cluser_coefficient order by cluser_coefficient descreturn id, degree, cluser_coefficient